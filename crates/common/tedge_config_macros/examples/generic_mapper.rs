// This example demonstrates the sub-fields functionality for tedge_config.
//
// STATUS: The key enum generation works! The macro successfully generates:
// - ReadableKey::MapperTyC8y(Option<String>, C8yReadableKey)
// - WritableKey::MapperTyC8y(Option<String>, C8yWritableKey)
// - DtoKey::MapperTyC8y(Option<String>, C8yDtoKey)
//
// STILL TODO (out of scope for current implementation):
// - Generate `from_dto_fragment` method automatically
// - Handle sub-field keys in read_string/write_string match arms
// - Implement Default for OptionalConfig<T> where T has sub_fields
// - Handle AppendRemoveItem for enum types with sub_fields
//
// The compilation errors you see are expected - they show the missing pieces
// that would be part of future work to fully support sub-fields.

use tedge_config_macros::*;

#[derive(thiserror::Error, Debug)]
pub enum ReadError {
    #[error(transparent)]
    ConfigNotSet(#[from] ConfigNotSet),
    #[error("Something went wrong: {0}")]
    GenericError(String),
    #[error(transparent)]
    Multi(#[from] tedge_config_macros::MultiError),
}

pub trait AppendRemoveItem {
    type Item;

    fn append(current_value: Option<Self::Item>, new_value: Self::Item) -> Option<Self::Item>;

    fn remove(current_value: Option<Self::Item>, remove_value: Self::Item) -> Option<Self::Item>;
}

impl<T> AppendRemoveItem for T {
    type Item = T;

    fn append(_current_value: Option<Self::Item>, _new_value: Self::Item) -> Option<Self::Item> {
        unimplemented!()
    }

    fn remove(_current_value: Option<Self::Item>, _remove_value: Self::Item) -> Option<Self::Item> {
        unimplemented!()
    }
}

define_tedge_config! {
    device: {
        #[tedge_config(rename = "type")]
        ty: String,
    },
    #[tedge_config(multi)]
    mapper: {
        #[tedge_config(sub_fields = [C8y(C8y), Custom])]
        #[tedge_config(rename = "type")]
        ty: BridgeType,
    }
}

define_sub_config! {
    C8y {
        enable: bool,
    }
}

// Stub implementation of from_dto_fragment for BridgeTypeReader
// This would normally be generated by the macro
impl BridgeTypeReader {
    fn from_dto_fragment(dto: &BridgeTypeDto, key: std::borrow::Cow<'static, str>) -> Self {
        match dto {
            BridgeTypeDto::C8y { c8y: _ } => BridgeTypeReader::C8y {
                c8y: C8yReader {
                    enable: OptionalConfig::Empty(format!("{key}.c8y.enable").into()),
                },
            },
            BridgeTypeDto::Custom => BridgeTypeReader::Custom,
        }
    }
}

fn main() {
    // Test that we can create the main config type
    let mut config = TEdgeConfigDto::default();
    println!("Created config: {config:?}");

    // Test that the key enums exist with sub-fields
    let _readable_key = ReadableKey::MapperType(None);
    let _readable_subkey = ReadableKey::MapperTypeC8y(None, C8yReadableKey::Enable);

    let _writable_key = WritableKey::MapperType(None);
    let _writable_subkey = WritableKey::MapperTypeC8y(None, C8yWritableKey::Enable);

    println!("Successfully created all key variants!");

    config
        .try_update_str(&"mapper.c8y.enable".parse().unwrap(), "true")
        .unwrap();
    dbg!(&config);
}
