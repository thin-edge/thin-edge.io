// This example demonstrates the sub-fields functionality for tedge_config.
//
// STATUS: The key enum generation works! The macro successfully generates:
// - ReadableKey::MapperTyC8y(Option<String>, C8yReadableKey)
// - WritableKey::MapperTyC8y(Option<String>, C8yWritableKey)
// - DtoKey::MapperTyC8y(Option<String>, C8yDtoKey)
//
// STILL TODO (out of scope for current implementation):
// - Generate `from_dto_fragment` method automatically
// - Handle sub-field keys in read_string/write_string match arms
// - Implement Default for OptionalConfig<T> where T has sub_fields
// - Handle AppendRemoveItem for enum types with sub_fields
//
// The compilation errors you see are expected - they show the missing pieces
// that would be part of future work to fully support sub-fields.

use tedge_config_macros::*;

#[derive(thiserror::Error, Debug)]
pub enum ReadError {
    #[error(transparent)]
    ConfigNotSet(#[from] ConfigNotSet),
    #[error("Something went wrong: {0}")]
    GenericError(String),
    #[error(transparent)]
    Multi(#[from] tedge_config_macros::MultiError),
}

pub trait AppendRemoveItem {
    type Item;

    fn append(current_value: Option<Self::Item>, new_value: Self::Item) -> Option<Self::Item>;

    fn remove(current_value: Option<Self::Item>, remove_value: Self::Item) -> Option<Self::Item>;
}

impl<T> AppendRemoveItem for T {
    type Item = T;

    fn append(_current_value: Option<Self::Item>, _new_value: Self::Item) -> Option<Self::Item> {
        unimplemented!()
    }

    fn remove(_current_value: Option<Self::Item>, _remove_value: Self::Item) -> Option<Self::Item> {
        unimplemented!()
    }
}

define_tedge_config! {
    #[tedge_config(multi)]
    mapper: {
        #[tedge_config(sub_fields = [C8y(C8y), Custom])]
        #[tedge_config(rename = "type")]
        ty: BridgeType,
    }
}

// Manual definitions for the sub-field types (normally would be generated by a future macro)
// These represent the C8y-specific configuration

// The DTO type for C8y config fragment
#[derive(
    Debug, Default, Clone, PartialEq, Eq, doku::Document, serde::Deserialize, serde::Serialize,
)]
pub struct C8yDto {
    enable: Option<bool>,
}

impl C8yDto {
    pub fn try_update_str(&mut self, key: &C8yWritableKey, value: &str) -> Result<(), WriteError> {
        match key {
            C8yWritableKey::Enable => {
                self.enable = Some(
                    value
                        .parse()
                        .map_err(|e| WriteError::ParseValue(Box::new(e)))?,
                );
                Ok(())
            }
        }
    }

    pub fn take_value_from(
        &mut self,
        other: &mut C8yDto,
        key: &C8yWritableKey,
    ) -> Result<(), WriteError> {
        match key {
            C8yWritableKey::Enable => {
                self.enable = other.enable.take();
                Ok(())
            }
        }
    }

    pub fn try_unset_key(&mut self, key: &C8yWritableKey) -> Result<(), WriteError> {
        match key {
            C8yWritableKey::Enable => {
                self.enable = None;
                Ok(())
            }
        }
    }

    pub fn try_append_str(
        &mut self,
        _reader: &TEdgeConfigReader,
        key: &C8yWritableKey,
        value: &str,
    ) -> Result<(), WriteError> {
        match key {
            C8yWritableKey::Enable => {
                // For bool, append doesn't make sense, so we just set it
                self.enable = Some(
                    value
                        .parse()
                        .map_err(|e| WriteError::ParseValue(Box::new(e)))?,
                );
                Ok(())
            }
        }
    }

    pub fn try_remove_str(
        &mut self,
        _reader: &TEdgeConfigReader,
        key: &C8yWritableKey,
        _value: &str,
    ) -> Result<(), WriteError> {
        match key {
            C8yWritableKey::Enable => {
                self.enable = None;
                Ok(())
            }
        }
    }
}

// The Reader type for C8y config fragment
#[derive(Debug, Clone, PartialEq, Eq, doku::Document, serde::Serialize)]
pub struct C8yReader {
    enable: OptionalConfig<bool>,
}

impl C8yReader {
    pub fn read_string(&self, key: &C8yReadableKey) -> Result<String, ReadError> {
        match key {
            C8yReadableKey::Enable => Ok(self.enable.or_config_not_set()?.to_string()),
        }
    }
}

// The key enums that would be generated for C8y sub-fields
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum C8yReadableKey {
    Enable,
}

impl C8yReadableKey {
    pub fn to_cow_str(&self) -> std::borrow::Cow<'static, str> {
        match self {
            C8yReadableKey::Enable => "enable".into(),
        }
    }
}

impl std::str::FromStr for C8yReadableKey {
    type Err = ParseKeyError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "enable" => Ok(C8yReadableKey::Enable),
            _ => Err(ParseKeyError::Unrecognised(s.to_string())),
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum C8yWritableKey {
    Enable,
}

impl C8yWritableKey {
    pub fn to_cow_str(&self) -> std::borrow::Cow<'static, str> {
        match self {
            C8yWritableKey::Enable => "enable".into(),
        }
    }
}

impl std::str::FromStr for C8yWritableKey {
    type Err = ParseKeyError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "enable" => Ok(C8yWritableKey::Enable),
            _ => Err(ParseKeyError::Unrecognised(s.to_string())),
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum C8yDtoKey {
    Enable,
}

impl C8yDtoKey {
    pub fn to_cow_str(&self) -> std::borrow::Cow<'static, str> {
        match self {
            C8yDtoKey::Enable => "enable".into(),
        }
    }
}

impl std::str::FromStr for C8yDtoKey {
    type Err = ParseKeyError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "enable" => Ok(C8yDtoKey::Enable),
            _ => Err(ParseKeyError::Unrecognised(s.to_string())),
        }
    }
}

// Stub implementation of from_dto_fragment for BridgeTypeReader
// This would normally be generated by the macro
impl BridgeTypeReader {
    fn from_dto_fragment(dto: &BridgeTypeDto, key: std::borrow::Cow<'static, str>) -> Self {
        match dto {
            BridgeTypeDto::C8y { c8y: _ } => BridgeTypeReader::C8y {
                c8y: C8yReader {
                    enable: OptionalConfig::Empty(format!("{key}.c8y.enable").into()),
                },
            },
            BridgeTypeDto::Custom => BridgeTypeReader::Custom,
        }
    }
}

fn main() {
    // Test that we can create the main config type
    let mut config = TEdgeConfigDto {
        mapper: MultiDto::default(),
    };
    println!("Created config: {config:?}");

    // Test that the key enums exist with sub-fields
    let _readable_key = ReadableKey::MapperType(None);
    let _readable_subkey = ReadableKey::MapperTypeC8y(None, C8yReadableKey::Enable);

    let _writable_key = WritableKey::MapperType(None);
    let _writable_subkey = WritableKey::MapperTypeC8y(None, C8yWritableKey::Enable);

    println!("Successfully created all key variants!");

    config
        .try_update_str(&"mapper.c8y.enable".parse().unwrap(), "true")
        .unwrap();
    dbg!(&config);
}
